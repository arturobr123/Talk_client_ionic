var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
import { getTranslationValues } from './translation-helper';
import { PanGesture } from 'ionic-angular/gestures/drag-gesture';
import { CSS, nativeRaf, pointerCoord } from 'ionic-angular/util/dom';
import { swipeShouldReset } from 'ionic-angular/util/util';
import { Animation } from 'ionic-angular';
var HAMMER_THRESHOLD = 10;
var MAX_ATTACK_ANGLE = 30;
export var ImageViewerSliderGesture = (function (_super) {
    __extends(ImageViewerSliderGesture, _super);
    function ImageViewerSliderGesture(component, domCtrl) {
        _super.call(this, component.getNativeElement(), {
            maxAngle: MAX_ATTACK_ANGLE,
            threshold: HAMMER_THRESHOLD,
            zone: false,
            gesture: component._gestureCtrl.createGesture({ name: 'image-viewer-slider' }),
            direction: 'x',
            domController: domCtrl
        });
        this.component = component;
        this.image = component.getNativeElement().querySelector('.image');
        this.translationX = 0;
        this.windowWidth = component
            .getNativeElement()
            .querySelector('ion-backdrop')
            .clientWidth;
        this.listen();
    }
    ImageViewerSliderGesture.prototype.onDragStart = function (ev) {
        this.initialTranslation = getTranslationValues(this.image);
        var coord = pointerCoord(ev);
        this.startX = coord.x;
        return true;
    };
    ImageViewerSliderGesture.prototype.canStart = function () {
        return !this.component.isZoomed;
    };
    ImageViewerSliderGesture.prototype.onDragMove = function (ev) {
        var _this = this;
        var coord = pointerCoord(ev);
        this.translationX = this.initialTranslation.x + coord.x - this.startX;
        nativeRaf(function () {
            _this.image.style[CSS.transform] = "translateX(" + _this.translationX + "px) translateY(0)";
        });
        return true;
    };
    ImageViewerSliderGesture.prototype.onDragEnd = function (ev) {
        var coordX = pointerCoord(ev).x;
        var deltaX = (coordX - this.startX);
        var velocity = deltaX / (Date.now() - this.firstTimestamp);
        var isResetDirection = (deltaX > 0) === !(velocity < 0);
        var isMovingFast = Math.abs(velocity) > 0.3;
        var isOnCloseZone = Math.abs(deltaX) < Math.abs(this.windowWidth / 2);
        var moveX = (swipeShouldReset(isResetDirection, isMovingFast, isOnCloseZone)) ? 0 : Math.sign(deltaX) * this.windowWidth;
        var endPoint = this.initialTranslation.x + moveX;
        var duration = 150 - (150 * deltaX / this.windowWidth);
        var imageWrapperAnimation = new Animation(this.image);
        imageWrapperAnimation.fromTo('translateX', this.translationX + "px", endPoint + "px");
        new Animation()
            .easing('ease-in')
            .duration(duration)
            .add(imageWrapperAnimation)
            .play();
        return true;
    };
    return ImageViewerSliderGesture;
}(PanGesture));
//# sourceMappingURL=image-viewer-slider-gesture.js.map